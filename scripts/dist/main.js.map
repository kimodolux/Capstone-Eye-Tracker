{"version":3,"sources":["main.js"],"names":["$","document","ready","window","pauseToggle","videoToggle","menuToggle","chrome","storage","local","get","result","console","log","model_trained","storageFunctions","loadBestModel","ui","enableButtons","setInterval","renderPrediction","prediction","model","current_model","isTraining","start","performance","now","time","gaze_prediction","predict","timeEnd","gaze_x","gaze_y","integrationTests","test_prediction_output","x","width","pointer","pointer_size","y","innerHeight","y_offset","scrollY","movePointer","heatmap","draw","end","ex_time","assert","errorMsg"],"mappings":";AAAA,SAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,GAAA,IAAA,IAAA,EAAA,EAAA,GAAA,GAAA,EAAA,EAAA,MAAA,MAAA,GAAA,YAAA,EAAA,GAAA,EAAA,KAAA,EAAA,GAAA,QAAA,QAAA,GAAA,KAAA,EAAA,GAAA,SAAA,EAAA,GAAA,OAAA,WAAA,IAAA,EAAA,KAAA,EAAA,UAAA,OAAA,IAAA,QAAA,SAAA,EAAA,GAAA,IAAA,EAAA,EAAA,MAAA,EAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,OAAA,GAAA,SAAA,EAAA,GAAA,EAAA,EAAA,EAAA,EAAA,EAAA,EAAA,QAAA,GAAA,OAAA,MAAAA,EAAEC,UAAUC,MAAM,WAGjBC,OAAOC,aAAc,EACrBD,OAAOE,aAAc,EACrBF,OAAOG,YAAa,EAkEpBC,OAAOC,QAAQC,MAAMC,IAAI,CAAC,iBAA1B,WAAA,IAAA,EAAA,EAA4C,mBAAA,KAAA,SAAeC,EAAAA,GAAf,OAAA,mBAAA,KAAA,SAAA,GAAA,OAAA,OAAA,EAAA,KAAA,EAAA,MAAA,KAAA,EAC3CC,QAAQC,IAAIF,EAAOG,eACS,GAAxBH,EAAOG,gBACVC,iBAAiBC,gBACjBC,GAAGC,gBACHN,QAAQC,IAAI,4BAL8B,KAAA,EAAA,IAAA,MAAA,OAAA,EAAA,SAAA,MAA5C,OAAA,SAAA,GAAA,OAAA,EAAA,MAAA,KAAA,YAAA,IAcAM,YA9ESC,SAAiBC,GAKrBC,GAAuB,MAAvBA,MAAMC,cAEH,GAAwB,GAApBD,MAAME,WAAV,CAKPZ,QAAQC,IAAI,IAGRY,IAAAA,EAAQtB,OAAOuB,YAAYC,MAC/Bf,QAAQgB,KAAK,kBAIbhB,QAAQgB,KAAK,mBACPC,IAAAA,EAAkBP,MAAMQ,UAC9BlB,QAAQmB,QAAQ,mBAEZC,IAAAA,EAASH,EAAgB,GACvBI,EAASJ,EAAgB,GAI/BK,iBAAiBC,uBAAuBH,EAAQC,GAK1CG,IAAAA,EAAIJ,GAAUhC,EAAE,QAAQqC,QAAUC,QAAQC,cAC1CC,EAAGP,GAAU9B,OAAOsC,YAAcH,QAAQC,cAI1CG,EAAWF,EAAIrC,OAAOwC,QAGT,GAAfvC,cACHkC,QAAQM,YAAYR,EAAEI,GACtBK,QAAQC,KAAKV,EAAEM,IAKhB9B,QAAQmB,QAAQ,kBACZgB,IAGAC,EAHM7C,OAAOuB,YAAYC,MAGTF,EAEpBb,QAAQqC,OAAOD,EAAU,IAAK,CAACA,QAASA,EAASE,SADlC,yCAKftC,QAAQC,IAAI,gBAAkBuB,EAAI,KAAOI,EAAI,UAnD5C5B,QAAQC,IAAI,sBAsEgB","file":"main.js","sourceRoot":"..","sourcesContent":["$(document).ready(function() {\r\n\t\r\n\t//global boolean toggles for pausing tracking, and video/menu displays\r\n\twindow.pauseToggle = false;\r\n\twindow.videoToggle = false;\r\n\twindow.menuToggle = false;\r\n\t\r\n\tfunction renderPrediction(prediction){\r\n\t\t\r\n\t\t//make a prediction using the Convolutional neural network\r\n\t\t//exteracts an image of the user's eyes from the current webcam frame\r\n\t\t//and uses the classifier to predict where the user is gazing\r\n\t\tif (model.current_model == null){\t\r\n\t\t\treturn;\r\n\t\t} else if (model.isTraining == true){\r\n\t\t\tconsole.log(\"model in training\");\r\n\t\t\treturn;\r\n\t\t} \r\n\r\n\t\tconsole.log(\"\");\r\n\r\n\t\t//performance testing of execution time\r\n\t\tvar start = window.performance.now();\r\n\t\tconsole.time('Execution Time');\r\n\r\n\t\t//generate a prediction by extracting an image of the user's eyes\r\n\t\t//and inputting it into the Neural Network.\r\n\t\tconsole.time('model.predict()');\r\n\t\tconst gaze_prediction = model.predict();\r\n\t\tconsole.timeEnd('model.predict()');\r\n\r\n\t\tvar gaze_x = gaze_prediction[0];\r\n\t\tconst gaze_y = gaze_prediction[1];\r\n\r\n\t\t/////////////////////////////////////////////////////////////////////\r\n\t\t//Integration Test which checks the validity of the output prediction\r\n\t\tintegrationTests.test_prediction_output(gaze_x, gaze_y);\r\n\t\t/////////////////////////////////////////////////////////////////////\r\n\t\t\r\n\r\n\t\t//extract the x and y coordinates of the prediciton\r\n\t\tconst x = gaze_x * ($('body').width() - pointer.pointer_size);\r\n\t\tconst y= gaze_y * (window.innerHeight - pointer.pointer_size);\r\n\t\t\r\n\t\t//for the heatmap, add a datapoint at the location of the pointer\r\n\t\t//plus the offset from the top of the page after scrolling\r\n\t\tconst y_offset = y + window.scrollY;\r\n\r\n\t\t//if not paused, draw pointer and heatmap\r\n\t\tif (pauseToggle == false){\r\n\t\t\tpointer.movePointer(x,y);\r\n\t\t\theatmap.draw(x,y_offset);\t\r\n\t\t}\r\n\t\t\r\n\r\n\t\t//performance testing of execution time\r\n\t\tconsole.timeEnd('Execution Time');\r\n\t\tvar end = window.performance.now();\r\n\t\t\r\n\t\t//Performance test: assert execution time isn't longer than 100ms\r\n\t\tvar ex_time = end - start;\r\n\t\tvar errorMsg = \"Execution time was longer than 100ms\";\r\n\t\tconsole.assert(ex_time < 100, {ex_time: ex_time, errorMsg: errorMsg});\r\n\r\n\r\n\t\t//output prediction result to console\r\n\t\tconsole.log(\"Prediction: (\" + x + \", \" + y + \")\");\r\n\r\n\t}\r\n\r\n\t//if a model has already been trained in the browser session, load it\r\n\tchrome.storage.local.get(['model_trained'], async function(result){\r\n\t\tconsole.log(result.model_trained);\r\n\t\tif (result.model_trained == true){\r\n\t\t\tstorageFunctions.loadBestModel();\r\n\t\t\tui.enableButtons();\r\n\t\t\tconsole.log(\"Model Loaded on Startup\");\r\n\t\t}\r\n\t});\r\n\r\n\t////////////////////////////////////////////////////////\r\n\t// Process a prediction every 150ms                    //\r\n\t////////////////////////////////////////////////////////\r\n\r\n\t//set the interval at which to refresh the predictions and draw the pointer\r\n\tsetInterval(renderPrediction, 150);\r\n\r\n\t////////////////////////////////////////////////////////\r\n\t// Process a prediction every 150ms                    //\r\n\t////////////////////////////////////////////////////////\r\n\r\n});"]}